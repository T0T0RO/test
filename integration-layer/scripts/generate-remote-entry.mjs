#!/usr/bin/env node
// integration-layer/scripts/generate-remote-entry.mjs
// Build-only: bundle each remote's bootstrap into dist/_mf2/bootstrap.mjs (ESM)
// and emit dist/remoteEntry.js that re-exports mount/unmount/meta.

import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const integrationRoot = path.resolve(__dirname, "..");
const configPath = path.resolve(integrationRoot, "remote-configs", "mfe.config.json");

const log = {
  info: (m) => console.log(`[INFO] ${m}`),
  ok: (m) => console.log(`[OK] ${m}`),
  warn: (m) => console.warn(`[WARN] ${m}`),
  err: (m) => console.error(`[ERR] ${m}`)
};

let esbuild;
try {
  esbuild = await import("esbuild");
} catch {
  log.err(`esbuild not found. Install once: npm i -D esbuild --prefix integration-layer`);
  process.exit(1);
}

function loadSSOT() {
  if (!fs.existsSync(configPath)) throw new Error(`mfe.config.json not found at ${configPath}`);
  const raw = fs.readFileSync(configPath, "utf8");
  const json = JSON.parse(raw);
  const remotes = Array.isArray(json) ? json : json.remotes;
  if (!Array.isArray(remotes)) throw new Error(`mfe.config.json has no "remotes" array`);
  return remotes;
}

function resolveRoot(p) {
  return path.isAbsolute(p) ? p : path.resolve(integrationRoot, p);
}
function ensureDir(p) { fs.mkdirSync(p, { recursive: true }); }

function writeRemoteEntry(distDir, remoteName, framework, version, bundledRelImport) {
  const outPath = path.join(distDir, "remoteEntry.js");
  const now = new Date().toISOString();
  const contents = `// Auto-generated by generate-remote-entry.mjs
// Generated at: ${now}
// Do not edit manually.

export const meta = {
  name: ${JSON.stringify(remoteName)},
  framework: ${JSON.stringify(framework || "unknown")},
  version: ${JSON.stringify(version || "X")}
};

export async function mount(container, props) {
  if (!container) throw new Error("mount: container HTMLElement is required");
  const mod = await import(${JSON.stringify(bundledRelImport)});
  const fn = mod.bootstrap || mod.mount || mod.default;
  if (typeof fn !== "function") throw new Error("No bootstrap/mount function found in ${bundledRelImport}");
  return fn(container, props);
}

export async function unmount(container) {
  if (!container) throw new Error("unmount: container HTMLElement is required");
  const mod = await import(${JSON.stringify(bundledRelImport)});
  const fn = mod.teardown || mod.unmount;
  if (typeof fn === "function") return fn(container);
  container.innerHTML = "";
}

export default { meta, mount, unmount };
`;
  fs.writeFileSync(outPath, contents, "utf8");
  return outPath;
}

async function bundleBootstrap(remote) {
  const root = resolveRoot(remote.root);
  const distDir = path.join(root, "dist");
  const mf2Dir = path.join(distDir, "_mf2");
  ensureDir(mf2Dir);

  const bootstrapRel = remote.bootstrap || "src/bootstrap.ts";
  const bootstrapAbs = path.resolve(root, bootstrapRel);
  if (!fs.existsSync(bootstrapAbs)) throw new Error(`[${remote.name}] bootstrap not found at ${bootstrapAbs}`);

  const publicBase = `/remotes/${remote.name}/_mf2/`;

  // integration-layer/scripts/generate-remote-entry.mjs (esbuild part only)
  await esbuild.build({
    entryPoints: [bootstrapAbs],
    outdir: mf2Dir,
    entryNames: "bootstrap",
    format: "esm",
    platform: "browser",
    target: "es2020",
    bundle: true,
    splitting: false,
    sourcemap: false,
    logLevel: "silent",
    loader: {
      ".svg": "file",
      ".png": "file",
      ".jpg": "file",
      ".jpeg": "file",
      ".gif": "file",
      ".webp": "file",
      ".css": "css",
      ".tsx": "tsx",
      ".ts": "ts"
    },
    publicPath: publicBase,
    outExtension: { ".js": ".mjs" },
    define: {
      "process.env.NODE_ENV": JSON.stringify("development"),
      "import.meta.env.MODE": JSON.stringify("development")
    },
    plugins: [
      {
        name: "rewrite-root-imports",
        setup(build) {
          build.onResolve({ filter: /^\/[^/]/ }, (args) => {
            const absDist = path.resolve(root, "dist", args.path.slice(1));
            if (fs.existsSync(absDist)) return { path: absDist };
            const absSrc = path.resolve(root, args.path.slice(1));
            if (fs.existsSync(absSrc)) return { path: absSrc };
            return null;
          });
        }
      }
    ],
    // IMPORTANT: do NOT externalize Angular; bundle it into each remote
    external: []
  });

  const relImport = "./_mf2/bootstrap.mjs";
  return { distDir, relImport };
}

async function main() {
  log.info(`Starting unified remoteEntry generation at ${new Date().toISOString()}`);
  const remotes = loadSSOT();
  const summary = [];

  for (const r of remotes) {
    try {
      const { distDir, relImport } = await bundleBootstrap(r);
      writeRemoteEntry(distDir, r.name, r.framework, r.version, relImport);
      log.ok(`${r.name}: remoteEntry.js written (bundled bootstrap at ${relImport})`);
      summary.push([r.name, r.framework || "?", true, relImport]);
    } catch (e) {
      log.err(`${r.name}: ${e instanceof Error ? e.message : String(e)}`);
      summary.push([r.name, r.framework || "?", false, "ERROR"]);
    }
  }

  console.log(`\n=== Bundling Summary ===
Remote Name            Framework  OK       Bundled Import
----------------------------------------------------------------------`);
  for (const [name, fw, ok, imp] of summary) {
    const pad = (s, n) => String(s).padEnd(n, " ");
    console.log(`${pad(name, 22)}${pad(fw, 11)}${pad(ok ? "yes" : "no", 8)}${imp}`);
  }
  console.log(`======================================================================\n`);
  log.info("All remotes processed.");
}

main().catch((e) => {
  log.err(e?.stack || String(e));
  process.exit(1);
});
