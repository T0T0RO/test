// integration-layer/scripts/generate-remote-entry.mjs
// Unified dist-level remoteEntry generator for all remotes.
// Respects optional `bootstrap` in mfe.config.json, with clean logs.

import fs from "fs";
import { readFile, writeFile, mkdir, access } from "fs/promises";
import { constants as fsConstants } from "fs";
import path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const INTEGRATION_LAYER_ROOT = path.resolve(__dirname, "..");
const CONFIG_PATH = path.join(INTEGRATION_LAYER_ROOT, "remote-configs", "mfe.config.json");

const timestamp = new Date().toISOString();
const HEADER = `// Auto-generated by generate-remote-entry.mjs
// Generated at: ${timestamp}
// Do not edit manually.\n\n`;

// async exists
async function exists(p) {
  try {
    await access(p, fsConstants.F_OK);
    return true;
  } catch {
    return false;
  }
}

// sync exists
function existsSync(p) {
  try {
    fs.accessSync(p, fsConstants.F_OK);
    return true;
  } catch {
    return false;
  }
}

async function main() {
  console.log(`[INFO] Starting unified remoteEntry generation at ${timestamp}`);

  if (!(await exists(CONFIG_PATH))) {
    console.error(`[ERROR] Config not found at ${CONFIG_PATH}`);
    process.exit(1);
  }

  const raw = await readFile(CONFIG_PATH, "utf8");
  const config = JSON.parse(raw);
  const remotes = Array.isArray(config) ? config : config.remotes;

  if (!remotes) {
    console.error("[ERROR] No remotes defined in mfe.config.json");
    process.exit(1);
  }

  const summary = [];

  for (const remote of remotes) {
    try {
      const remoteRoot = path.isAbsolute(remote.root)
        ? remote.root
        : path.resolve(INTEGRATION_LAYER_ROOT, remote.root);

      const distDir = path.join(remoteRoot, "dist");
      await mkdir(distDir, { recursive: true });

      const { bootstrapPath, detected } = detectBootstrap(remote, remoteRoot);

      if (detected) {
        console.log(`[INFO] ${remote.name}: Using bootstrap "${bootstrapPath}"`);
      } else {
        console.warn(
          `[WARN] ${remote.name}: No explicit or known bootstrap found, using fallback "${bootstrapPath}"`
        );
      }

      const entryPath = path.join(distDir, "remoteEntry.js");
      const snippet = buildWrapperSnippet(remote, bootstrapPath);
      await writeFile(entryPath, HEADER + snippet, "utf8");

      summary.push({
        name: remote.name,
        framework: remote.framework,
        bootstrap: bootstrapPath,
        detected,
      });

      console.log(`[OK] ${remote.name}: remoteEntry.js written.`);
    } catch (err) {
      console.error(`[ERROR] ${remote.name}: Failed to generate remoteEntry.js: ${err.message}`);
      summary.push({
        name: remote.name,
        framework: remote.framework,
        bootstrap: "(error)",
        detected: false,
      });
    }
  }

  printSummary(summary);
  console.log("[INFO] All remotes processed.");
}

/**
 * Determine which bootstrap module to use.
 * Priority:
 *  1. remote.bootstrap from mfe.config.json (if exists)
 *  2. Known conventional files
 *  3. Fallback: "./main.js"
 */
function detectBootstrap(remote, remoteRoot) {
  // 1) Explicit bootstrap from config
  if (remote.bootstrap) {
    const explicitFull = path.join(remoteRoot, remote.bootstrap);
    if (existsSync(explicitFull)) {
      const rel = path.relative(path.join(remoteRoot, "dist"), explicitFull);
      const posix = normalizeRel(rel);
      return { detected: true, bootstrapPath: posix };
    } else {
      console.warn(
        `[WARN] ${remote.name}: Configured bootstrap "${remote.bootstrap}" not found. Falling back to auto-detect.`
      );
    }
  }

  // 2) Auto-detect common locations (src + dist)
  const candidates = [
    "src/bootstrap.ts",
    "src/bootstrap.tsx",
    "src/main.ts",
    "src/main.tsx",
    "src/main.js",
    "dist/app/browser/main.js",
    "dist/browser/main.js",
    "dist/main.js",
  ];

  for (const rel of candidates) {
    const full = path.join(remoteRoot, rel);
    if (existsSync(full)) {
      const relFromDist = path.relative(path.join(remoteRoot, "dist"), full);
      const posix = normalizeRel(relFromDist);
      return { detected: true, bootstrapPath: posix };
    }
  }

  // 3) Fallback
  return { detected: false, bootstrapPath: "./main.js" };
}

function normalizeRel(relPath) {
  const posix = relPath.split(path.sep).join("/");
  return posix.startsWith(".") ? posix : "./" + posix;
}

/**
 * Generate wrapper that adapts bootstrap module to MF2 contract.
 */
function buildWrapperSnippet(remote, bootstrapPath) {
  const { name, framework, version = "X" } = remote;

  return `export const meta = {
  name: ${JSON.stringify(name)},
  framework: ${JSON.stringify(framework)},
  version: ${JSON.stringify(version)}
};

export async function mount(container, props) {
  if (!container) throw new Error("mount: container HTMLElement is required");
  const mod = await import(${JSON.stringify(bootstrapPath)});
  const fn = mod.bootstrap || mod.mount || mod.default;
  if (typeof fn !== "function") {
    throw new Error("No bootstrap or mount function found in ${bootstrapPath}");
  }
  return fn(container, props);
}

export async function unmount(container) {
  if (!container) throw new Error("unmount: container HTMLElement is required");
  const mod = await import(${JSON.stringify(bootstrapPath)});
  const fn = mod.teardown || mod.unmount;
  if (typeof fn === "function") {
    return fn(container);
  }
  container.innerHTML = "";
}

export default { meta, mount, unmount };
`;
}

/**
 * Print detection summary
 */
function printSummary(summary) {
  console.log("\n=== Bootstrap Detection Summary ===");
  console.log(
    "Remote Name".padEnd(22),
    "Framework".padEnd(10),
    "Detected".padEnd(10),
    "Bootstrap Path"
  );
  console.log("-".repeat(70));
  for (const s of summary) {
    console.log(
      s.name.padEnd(22),
      String(s.framework || "-").padEnd(10),
      String(s.detected).padEnd(10),
      s.bootstrap
    );
  }
  console.log("=".repeat(70) + "\n");
}

await main().catch((err) => {
  console.error("[FATAL] generate-remote-entry failed:", err.message);
  process.exitCode = 1;
});
