// integration-layer/scripts/generate-remote-manifest.mjs
// Emits a NAMED export `remoteManifest` as a map { [name]: { entry, framework, version, status } }.

import fs from "fs";
import { readFile, writeFile, access } from "fs/promises";
import { fileURLToPath } from "url";
import path from "path";
import { constants as fsConstants } from "fs";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const INTEGRATION_ROOT = path.resolve(__dirname, "..");
const CONFIG_PATH = path.join(INTEGRATION_ROOT, "remote-configs", "mfe.config.json");

const SHELL_SRC_MANIFEST = path.join(INTEGRATION_ROOT, "shell", "src", "remote-manifest.js");
const DIST_MANIFEST = path.join(INTEGRATION_ROOT, "dist", "remote-manifest.js");

const timestamp = new Date().toISOString();
const HEADER = `// Auto-generated by generate-remote-manifest.mjs
// Generated at: ${timestamp}
// Do not edit manually.

`;

async function exists(p) {
  try { await access(p, fsConstants.F_OK); return true; } catch { return false; }
}

async function findRemoteEntry(remoteRoot) {
  const direct = path.join(remoteRoot, "dist", "remoteEntry.js");
  if (await exists(direct)) return direct;

  const distDir = path.join(remoteRoot, "dist");
  if (!(await exists(distDir))) return null;

  const entries = fs.readdirSync(distDir, { withFileTypes: true });
  for (const e of entries) {
    if (e.isDirectory()) {
      const candidate = path.join(distDir, e.name, "remoteEntry.js");
      if (fs.existsSync(candidate)) return candidate;
    }
  }
  return null;
}

async function main() {
  console.log(`[generate-remote-manifest] Running generate-remote-manifest.mjs with env="local".`);

  if (!(await exists(CONFIG_PATH))) {
    console.error(`[generate-remote-manifest] Fatal error: Config not found at "${CONFIG_PATH}"`);
    process.exit(1);
  }

  const raw = await readFile(CONFIG_PATH, "utf8");
  const config = JSON.parse(raw);
  const remotes = Array.isArray(config) ? config : config.remotes;

  if (!remotes || !Array.isArray(remotes)) {
    console.error(`[generate-remote-manifest] Fatal error: "remotes" array missing in mfe.config.json.`);
    process.exit(1);
  }

  const manifest = {};

  for (const remote of remotes) {
    const { name, root, framework, version = "X" } = remote;
    if (!name || !root || !framework) {
      console.warn(`[generate-remote-manifest] Remote entry incomplete (name/root/framework). Skipping.`);
      continue;
    }

    const remoteRoot = path.isAbsolute(root) ? root : path.resolve(INTEGRATION_ROOT, root);
    const distRemoteEntry = await findRemoteEntry(remoteRoot);

    if (!distRemoteEntry) {
      console.warn(`[generate-remote-manifest] Remote "${name}": remoteEntry.js not found. Marking "missing".`);
      manifest[name] = { entry: null, framework, version, status: "missing" };
      continue;
    }

    console.log(`[generate-remote-manifest] Remote "${name}": found at "${distRemoteEntry}".`);
    manifest[name] = { entry: `/remotes/${name}/remoteEntry.js`, framework, version, status: "available" };
  }

  const content = HEADER + `export const remoteManifest = ${JSON.stringify(manifest, null, 2)};\n`;

  fs.mkdirSync(path.dirname(DIST_MANIFEST), { recursive: true });
  await writeFile(DIST_MANIFEST, content, "utf8");
  console.log(`[generate-remote-manifest] Wrote manifest to "${DIST_MANIFEST}".`);

  fs.mkdirSync(path.dirname(SHELL_SRC_MANIFEST), { recursive: true });
  await writeFile(SHELL_SRC_MANIFEST, content, "utf8");
  console.log(`[generate-remote-manifest] Copied manifest to "${SHELL_SRC_MANIFEST}".`);

  console.log("[generate-remote-manifest] Remote manifest generation completed.");
}

await main().catch((err) => {
  console.error("[generate-remote-manifest] Fatal error during manifest generation:", err);
  process.exit(1);
});
